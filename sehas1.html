<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Global Space Mission Budget vs Time (Success vs Failure)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background-color: #050505;
      color: #ffffff;
    }

    .chart-container {
      width: 100%;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at top, #222 0, #050505 60%);
    }

    svg {
      background-color: #111111;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
      border-radius: 12px;
    }

    .axis path,
    .axis line {
      stroke: #888;
    }

    .axis text {
      fill: #e0e0e0;
      font-size: 12px;
    }

    .grid line {
      stroke: #555;
      stroke-opacity: 0.3;
      stroke-dasharray: 4 4;
    }

    .grid path {
      stroke: none;
    }

    .legend {
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }

    .legend text {
      fill: #f5f5f5;
    }

    .legend rect {
      stroke: #fff;
      stroke-width: 0.5px;
    }

    .legend-inactive rect {
      opacity: 0.3;
    }

    .legend-inactive text {
      opacity: 0.3;
    }

    .title {
      font-size: 16px;
      font-weight: 600;
      fill: #ffffff;
    }

    .axis-label {
      fill: #ffffff;
      font-size: 13px;
    }

    .line {
      fill: none;
      stroke-width: 2.5px;
      opacity: 0.9;
    }

    .line-success {
      stroke: lime;
    }

    .line-failure {
      stroke: red;
    }

    .dot {
      stroke: #000;
      stroke-width: 1px;
      opacity: 0.9;
      cursor: pointer;
    }

    .dot-success {
      fill: lime;
    }

    .dot-failure {
      fill: red;
    }

    .series-dimmed {
      opacity: 0.15;
      transition: opacity 200ms ease-out;
    }

    .series-highlight {
      opacity: 1;
      filter: drop-shadow(0 0 6px rgba(255,255,255,0.6));
      transition: opacity 200ms ease-out;
    }

    .tooltip {
      position: absolute;
      background-color: rgba(15, 15, 15, 0.95);
      color: #f8f8f8;
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.7);
      border: 1px solid #444;
      opacity: 0;
      transition: opacity 120ms ease-out;
      line-height: 1.35;
      white-space: nowrap;
      z-index: 10;
    }

    .project-dot {
      stroke: #000;
      stroke-width: 0.5px;
    }

    .project-line {
      fill: none;
      stroke: #cccccc;
      stroke-width: 1.5px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="chart-container">
    <svg id="chart"></svg>
  </div>

  <script>
    const margin = { top: 70, right: 220, bottom: 70, left: 70 };
    const width = 900;
    const height = 450;

    const svg = d3
      .select("#chart")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const tooltip = d3
      .select("body")
      .append("div")
      .attr("class", "tooltip");

    const outcomeColors = {
      Success: "lime",
      Failure: "red",
    };

    // Background rect for click-to-reset (capture empty space clicks)
    svg
      .insert("rect", ":first-child")
      .attr("class", "bg-rect")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", width)
      .attr("height", height)
      .style("fill", "transparent")
      .style("pointer-events", "all")
      .on("click", () => {
        tooltip.style("opacity", 0);
        updateYearView(null);
      });

    d3.csv("Global_Space_Exploration_Dataset.csv", (d, i) => {
      const name =
        d.Mission ||
        d["Mission"] ||
        d["Mission Name"] ||
        d["Project"] ||
        d["Project Name"] ||
        d["Mission/Project"] ||
        `Project ${i + 1}`;

      return {
        Year: +d.Year,
        SuccessRate: +d["Success Rate (%)"],
        Budget: +d["Budget (in Billion $)"],
        Name: name,
        Raw: d
      };
    }).then((data) => {
      data.forEach((d) => {
        d.Outcome = d.SuccessRate >= 75 ? "Success" : "Failure";
      });

      const rollup = d3.rollup(
        data,
        (v) => d3.sum(v, (d) => d.Budget),
        (d) => d.Year,
        (d) => d.Outcome
      );

      const groupedData = [];
      for (const [year, outcomeMap] of rollup.entries()) {
        for (const [outcome, totalBudget] of outcomeMap.entries()) {
          groupedData.push({
            Year: +year,
            Outcome: outcome,
            TotalBudget: totalBudget,
          });
        }
      }

      const outcomes = Array.from(
        new Set(groupedData.map((d) => d.Outcome))
      );

      const series = outcomes.map((outcome) => ({
        outcome,
        values: groupedData
          .filter((d) => d.Outcome === outcome)
          .sort((a, b) => d3.ascending(a.Year, b.Year)),
      }));

      const x = d3.scaleLinear().range([0, width]);
      const y = d3.scaleLinear().range([height, 0]);

      const xDomainFull = d3.extent(groupedData, (d) => d.Year);
      const yMaxFull = d3.max(groupedData, (d) => d.TotalBudget);
      const yDomainFull = [0, yMaxFull];

      x.domain(xDomainFull).nice();
      y.domain(yDomainFull).nice();

      const xAxis = d3.axisBottom(x).tickFormat(d3.format("d"));
      const yAxis = d3.axisLeft(y);
      const yGrid = d3.axisLeft(y).tickSize(-width).tickFormat("");

      svg.append("g").attr("class", "grid").call(yGrid);

      svg
        .append("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${height})`)
        .call(xAxis);

      svg.append("g").attr("class", "axis y-axis").call(yAxis);

      const line = d3
        .line()
        .x((d) => x(d.Year))
        .y((d) => y(d.TotalBudget));

      const seriesGroup = svg.append("g").attr("class", "series-group");
      const yearFocusGroup = svg.append("g").attr("class", "year-focus-group");

      const visibility = {};
      outcomes.forEach((o) => (visibility[o] = true));
      let selectedYear = null;

      // expose for bg click handler
      window.updateYearView = updateYearView;

      // Draw lines + dots
      series.forEach((s) => {
        const classSuffix = s.outcome === "Success" ? "success" : "failure";

        const path = seriesGroup
          .append("path")
          .datum(s.values)
          .attr("class", `line line-${classSuffix}`)
          .attr("data-outcome", s.outcome)
          .attr("d", line);

        const totalLength = path.node().getTotalLength();
        path
          .attr("stroke-dasharray", totalLength + " " + totalLength)
          .attr("stroke-dashoffset", totalLength)
          .transition()
          .duration(1500)
          .ease(d3.easeCubicOut)
          .attr("stroke-dashoffset", 0);

        const dots = seriesGroup
          .selectAll(`.dot-${classSuffix}`)
          .data(s.values)
          .enter()
          .append("circle")
          .attr("class", `dot dot-${classSuffix}`)
          .attr("data-outcome", s.outcome)
          .attr("cx", (d) => x(d.Year))
          .attr("cy", (d) => y(d.TotalBudget))
          .attr("r", 0);

        dots
          .transition()
          .delay((_, i) => 400 + i * 80)
          .duration(400)
          .attr("r", 4);

        dots
          .on("click", function (event, d) {
            event.stopPropagation();
            tooltip.style("opacity", 0);
            if (selectedYear === d.Year) {
              updateYearView(null);
            } else {
              updateYearView(d.Year);
            }
          })
          .on("mouseover", function (event, d) {
            const outcome = d.Outcome;
            const budgetFormatted = d.TotalBudget.toFixed(2);

            highlightSeries(outcome);

            tooltip
              .style("opacity", 1)
              .html(
                `<strong>${outcome}</strong><br/>Year: ${d.Year}<br/>Total Budget: ${budgetFormatted} B$`
              );

            d3.select(this)
              .raise()
              .transition()
              .duration(120)
              .attr("r", selectedYear === d.Year ? 0 : 7);
          })
          .on("mousemove", function (event) {
            tooltip
              .style("left", event.pageX + 15 + "px")
              .style("top", event.pageY - 10 + "px");
          })
          .on("mouseout", function (event, d) {
            resetHighlight();
            tooltip.style("opacity", 0);

            d3.select(this)
              .transition()
              .duration(120)
              .attr("r", function () {
                if (!selectedYear) return 4;
                return d.Year === selectedYear ? 0 : 3;
              });
          });
      });

      function highlightSeries(outcome) {
        seriesGroup
          .selectAll(".line, .dot")
          .classed("series-dimmed", true)
          .classed("series-highlight", false);

        seriesGroup
          .selectAll(`[data-outcome="${outcome}"]`)
          .classed("series-dimmed", false)
          .classed("series-highlight", true);
      }

      function resetHighlight() {
        seriesGroup
          .selectAll(".line, .dot")
          .classed("series-dimmed", false)
          .classed("series-highlight", false);
      }

      function updateYearView(year) {
        selectedYear = year;
        tooltip.style("opacity", 0);
        yearFocusGroup.selectAll("*").remove();

        if (!year) {
          // reset to full view
          x.domain(xDomainFull).nice();
          y.domain(yDomainFull).nice();
        } else {
          // zoom x around selected year
          x.domain([year - 0.5, year + 0.5]);

          // y domain based on project budgets for that year
          const yearProjects = data.filter(d => d.Year === year);
          let minProj  = d3.min(yearProjects, d => d.Budget);
          let maxProj  = d3.max(yearProjects, d => d.Budget);

          if (!isFinite(minProj) || !isFinite(maxProj)) {
            minProj = 0;
            maxProj = 1;
          }
          const padding = (maxProj - minProj) * 0.2 || 1;

          y.domain([minProj - padding, maxProj + padding]).nice();
        }

        d3.select(".x-axis")
          .transition()
          .duration(600)
          .call(xAxis);

        d3.select(".y-axis")
          .transition()
          .duration(600)
          .call(yAxis);

        // hide grid on zoom, show when reset (removes those lines after zoom in)
        d3.select(".grid")
          .transition()
          .duration(600)
          .style("opacity", year ? 0 : 1)
          .call(yGrid);

        seriesGroup
          .selectAll(".line")
          .transition()
          .duration(600)
          .attr("d", line);

        seriesGroup
          .selectAll(".dot")
          .transition()
          .duration(600)
          .attr("cx", (d) => x(d.Year))
          .attr("cy", (d) => y(d.TotalBudget))
          .attr("r", (d) => {
            if (!year) return 4;
            return d.Year === year ? 0 : 3; // hide aggregated-year dots in zoom view
          });

        if (year) {
          drawYearFocusOverlay(year);
        }
      }

      function drawYearFocusOverlay(year) {
        // Only project-wise line + dots, NO widget box
        const projects = data
          .filter((d) => d.Year === year)
          .sort((a, b) => d3.descending(a.Budget, b.Budget));

        const innerMargin = 40;
        const projX = d3
          .scaleBand()
          .domain(projects.map((_, i) => i))
          .range([innerMargin, width - innerMargin])
          .padding(0.2);

        const projectLine = d3
          .line()
          .x((_, i) => projX(i) + projX.bandwidth() / 2)
          .y((d) => y(d.Budget));

        if (projects.length > 1) {
          yearFocusGroup
            .append("path")
            .datum(projects)
            .attr("class", "project-line")
            .attr("d", projectLine);
        }

        const projDots = yearFocusGroup
          .selectAll(".project-dot")
          .data(projects)
          .enter()
          .append("circle")
          .attr("class", "project-dot")
          .attr("cx", (_, i) => projX(i) + projX.bandwidth() / 2)
          .attr("cy", (d) => y(d.Budget))
          .attr("r", 0)
          .attr("fill", (d) => outcomeColors[d.Outcome] || "#aaa")
          .on("click", (event) => {
            event.stopPropagation();
            tooltip.style("opacity", 0);
          });

        projDots
          .transition()
          .delay((_, i) => 150 + i * 40)
          .duration(300)
          .attr("r", 5);

        projDots
          .on("mouseover", function (event, d) {
            tooltip
              .style("opacity", 1)
              .html(
                `<strong>${d.Name}</strong><br/>Budget: ${d.Budget.toFixed(
                  2
                )} B$<br/>Outcome: ${d.Outcome}`
              );
          })
          .on("mousemove", function (event) {
            tooltip
              .style("left", event.pageX + 15 + "px")
              .style("top", event.pageY - 10 + "px");
          })
          .on("mouseout", function () {
            tooltip.style("opacity", 0);
          });
      }

      // Title & axis labels
      svg
        .append("text")
        .attr("class", "title")
        .attr("x", width / 2)
        .attr("y", -25)
        .attr("text-anchor", "middle")
        .text("Global Space Mission Budget vs Time (Success vs Failure)");

      svg
        .append("text")
        .attr("class", "axis-label")
        .attr("x", width / 2)
        .attr("y", height + 45)
        .attr("text-anchor", "middle")
        .text("Year");

      svg
        .append("text")
        .attr("class", "axis-label")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", -50)
        .attr("text-anchor", "middle")
        .text("Total Budget (in Billion $)");

      // Legend
      const legend = svg
        .append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${width + 25}, 0)`);

      outcomes.forEach((outcome, i) => {
        const yOff = i * 28;
        const color = outcomeColors[outcome];

        const legendItem = legend
          .append("g")
          .attr("transform", `translate(0, ${yOff})`)
          .attr("data-outcome", outcome)
          .on("click", (event) => event.stopPropagation());

        legendItem
          .append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", 18)
          .attr("height", 18)
          .attr("rx", 3)
          .attr("ry", 3)
          .attr("fill", color);

        legendItem
          .append("text")
          .attr("x", 26)
          .attr("y", 13)
          .text(outcome);

        legendItem
          .on("mouseover", () => highlightSeries(outcome))
          .on("mouseout", () => resetHighlight())
          .on("click", function (event) {
            event.stopPropagation();
            visibility[outcome] = !visibility[outcome];

            legendItem.classed("legend-inactive", !visibility[outcome]);

            const targetOpacity = visibility[outcome] ? 1 : 0;

            seriesGroup
              .selectAll(`[data-outcome="${outcome}"]`)
              .transition()
              .duration(300)
              .style("opacity", targetOpacity);
          });
      });
    });
  </script>
</body>
</html>
